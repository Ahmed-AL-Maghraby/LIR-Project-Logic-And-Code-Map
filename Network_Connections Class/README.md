




| Name | Access Modifiers | Objects | Inhert From | Number Of Function |
| ---- | ---------------- | ------- | ----------- | ------------------ |
| Network_Connections |      Plublic     | 1 |    none     |        10           |





## Objects
```c#
public static Form1 myform = System.Windows.Forms.Application.OpenForms.OfType<Form1>().FirstOrDefault();
```

## Methods


| Name | Type | Access Modifiers | Description |
| ---- | ---- | ---------------- | ----------- |
| [GetNetworkConnections]() | Void | Public | wwwwwwwwwwwwwwww |
| [netstatcommand]() | Void | Private | wwwwwwwwwwwwwwww |
| [netstat_output]() | Void | Private | wwwwwwwwwwwwwwww |
| [GetColumnAsArry]() | String[] | Private | wwwwwwwwwwwwwwww |
| [WriteColumnToCSV]() | Void | Private | wwwwwwwwwwwwwwww 
| [GetprocessName]() | Void | Private | wwwwwwwwwwwwwwww 
| [LoadCSV]() | DataTable | Public | wwwwwwwwwwwwwwww 
| [GetHostName]() | Void | Private | wwwwwwwwwwwwwwww 
| [AbuseIPDBScanAndCountry]() | Void | Private | wwwwwwwwwwwwwwww 
| [VirusTotalIpScanner]() | Void | Private | wwwwwwwwwwwwwwww 

<br>



## GetNetworkConnections
This function is the entry point of the process and serves as the main method to retrieve and process network connection data.

```c#
public void GetNetworkConnections()
        {
            myform.Networktable.DataSource = LoadCSV();
            foreach(DataGridViewRow row in myform.Networktable.Rows)
            {
                try
                {
                    if (int.Parse(row.Cells[10].Value.ToString()) > 0 || (int.Parse(row.Cells[11].Value.ToString()) > 0))
                    {
                        row.DefaultCellStyle.BackColor = Color.Red;
                        row.DefaultCellStyle.ForeColor = Color.White;
                    }
                }catch(Exception ex) { }
                
            }
            MessageBox.Show("Done");
        }
```
Here's how the function works:
   - It first calls the `LoadCSV()` method to load data from a CSV file into a DataTable, and then sets the DataTable as the data source of the `myform.Networktable` DataGridView control on the main form.
   - Next, it iterates through each row of the DataGridView.
   - For each row, it attempts to parse the values in columns 10 and 11 to integers using `int.Parse()`.
   - If the parsing is successful, it checks if either column 10 or column 11 has a value greater than zero, which indicates an active network connection.
   - If a row has an active network connection, it changes the background color to red and the foreground (text) color to white to visually highlight the connection.
   - Any exceptions that occur during parsing are caught and ignored using a try-catch block.
   - After processing all rows, it displays a message box showing "Done" to indicate the completion of the operation.

<br/>

## netstatcommand
This function runs the `netstat` command in the Windows command prompt (`cmd.exe`) and redirects the output to a file named "netstat_output.txt".
```c#
    private void netstatcommand()
        {
           // Process.Start("cmd", "/C netstat -no > netstat_output.txt");
            Process process = new Process();
            process.StartInfo.FileName = "cmd.exe";
            process.StartInfo.Arguments = "/C netstat -no > netstat_output.txt";
            process.Start();
            process.WaitForExit();

        }
```
Here's how the function works:
   - It creates a new `Process` object and sets its `FileName` property to "cmd.exe" and its `Arguments` property to "/C netstat -no > netstat_output.txt".
   - The `/C` parameter tells `cmd.exe` to run the specified command and then terminate.
   - The `process.Start()` method is called to start the process, and `process.WaitForExit()` is called to wait for the command to finish before continuing execution.

<br/>

## netstat_output
This function processes the "netstat_output.txt" file generated by the `netstatcommand()` method.
```c#
        private void netstat_output()
        {
            try
            {
                netstatcommand();
                string fileContents = File.ReadAllText("netstat_output.txt");
                string output = fileContents.Replace(" ", ",");
                for (int i = 0; i < 10; i++)
                {
                    output = output.Replace(",,", ",");
                }
                output = output.Replace("Active,Connections", "");
                output = output.Replace(':', ',');
                output = output.Replace(",Proto,Local,Address,Foreign,Address,State,PID", string.Empty);
                output = output.Replace("\n,", "\n");
                output = output.Trim();
                File.WriteAllText("netstat_output.csv", output);
            }
            catch (Exception e)
            {
            }
        }
```
 Here's how the function works:
   - It reads the entire contents of the file into a string variable `fileContents`.
   - Several string replacement operations are performed to clean up the content and format it correctly:
     - Replacing spaces with commas.
     - Replacing multiple consecutive commas with a single comma.
     - Removing the header line "Active,Connections".
     - Replacing colons with commas.
     - Removing the line with the column headers "Proto,Local,Address,Foreign,Address,State,PID".
   - The processed output is then written back to a new file named "netstat_output.csv".

<br/>

## GetColumnAsArry
This function reads a specific column from the "netstat_output.csv" CSV file and returns its values as an array of strings.
```c#
private string[] GetColumnAsArry(int columnIndex)
        {
            List<string> ColumnArray = new List<string>();
            using (TextFieldParser parser = new TextFieldParser("netstat_output.csv"))
            {
                parser.SetDelimiters(",");
                while (!parser.EndOfData)
                {
                    string[] fields = parser.ReadFields();
                    if (fields.Length > 1)
                    {
                        ColumnArray.Add(fields[columnIndex]);
                    }
                }
            }

            return ColumnArray.ToArray();
        }

```
Here's how the function works:
   - It initializes a List of strings named `ColumnArray` to store the values.
   - It uses a `TextFieldParser` to read the CSV file and set the delimiters to commas.
   - While reading the CSV file, it extracts the values from the specified column (based on the `columnIndex` parameter) and adds them to the `ColumnArray`.
   - After processing all rows, it converts the List to an array and returns it.

<br/>

## WriteColumnToCSV
This function writes a string array into a specific column of the "netstat_output.csv" CSV file.
```c#
private void WriteColumnToCSV(string[] column)
        {
            string[] lines = File.ReadAllLines("netstat_output.csv");
            for (int i = 0; i < lines.Length; i++)
            {
                string dataLine = lines[i];

                if (!string.IsNullOrEmpty(dataLine))
                {
                    string modifiedDataLine = dataLine + "," + column[i];
                    lines[i] = modifiedDataLine;
                }
            }

            File.WriteAllLines("netstat_output.csv", lines);
        }
```
Here's how the function works:
   - It reads all the lines from the CSV file into a string array named `lines`.
   - It then iterates through each line in the array.
   - For each line, it appends the value from the corresponding position in the `column` array (based on the index) and separated by a comma.
   - The modified lines are then written back to the "netstat_output.csv" file, effectively updating the specified column.

<br/>

## GetprocessName
This function retrieves the process names associated with the Process IDs (PIDs) present in the CSV file.
```c#
```
Here's how the function works:
   - It first retrieves the Process IDs from the CSV file using `GetColumnAsArry(6)`.
   - For each Process ID, it tries to get the corresponding `Process` object using `Process.GetProcessById()`.
   - If successful, it retrieves the process name and stores it in a string array named `names`.
   - If an exception occurs (e.g., the process does not exist), it stores "error" in the `names` array.
   - Finally, it calls `WriteColumnToCSV(names)` to update the "Process Name" column in the CSV file with the process names.

<br/>

## GetHostName
This function retrieves hostnames associated with the IP addresses present in the CSV file.
```c#
private void GetHostName()
        {
            string[] IPs = GetColumnAsArry(3);
            string[] hostname = new string[IPs.Length];
            for (int i = 0; i < IPs.Length; i++)
            {
                try
                {
                    IPHostEntry hostEntry = Dns.GetHostEntry(IPs[i]);
                    hostname[i] = hostEntry.HostName;
                }
                catch (Exception)
                {
                    hostname[i] = string.Empty;
                }
            }
            WriteColumnToCSV(hostname);
        }
```
Here's how the function works:
   - It first retrieves the IP addresses from the CSV file using `GetColumnAsArry(3)`.
   - For each IP address, it tries to get the corresponding `IPHostEntry` object using `Dns.GetHostEntry()`.
   - If successful, it retrieves the hostname and stores it in a string array named `hostname`.
   - If an exception occurs (e.g., DNS resolution fails), it stores an empty string in the `hostname` array.
   - Finally, it calls `WriteColumnToCSV(hostname)` to update the "Host Name" column in the CSV file with the hostnames.

<br/>

## AbuseIPDBScanAndCountry
 This function performs an API call to the AbuseIPDB service to obtain abuse confidence scores and country codes for the IP addresses present in the CSV file.
```c#
private void AbuseIPDBScanAndCountry()
        {
            string apikey = myform.AbuseIPDB_Api.Text;
            string[] IPs = GetColumnAsArry(3);
            string[] Score = new string[IPs.Length];
            string[] countrys = new string[IPs.Length];
            string ipAddress = string.Empty;
            string url = string.Empty;

            for (int i = 0; i < IPs.Length; i++)
            {
                ipAddress = IPs[i];
                url = $"https://api.abuseipdb.com/api/v2/check?ipAddress={ipAddress}";
                HttpClient client = new HttpClient();
                client.DefaultRequestHeaders.Add("Key", apikey);
                client.DefaultRequestHeaders.Add("Accept", "application/json");

                try
                {
                    HttpResponseMessage response = client.GetAsync(url).Result;
                    if (response.IsSuccessStatusCode)
                    {
                        Task<string> responseData = response.Content.ReadAsStringAsync();
                        string data = responseData.Result;
                        dynamic jsonData = Newtonsoft.Json.JsonConvert.DeserializeObject(data);
                        int abuseConfidenceScore = jsonData.data.abuseConfidenceScore;
                        string countryCode = jsonData.data.countryCode;

                        if (abuseConfidenceScore > 0)
                        {
                            Score[i] = abuseConfidenceScore.ToString();
                            countrys[i] = countryCode;
                        }
                        else
                        {
                            Score[i] = "0";
                            countrys[i] = countryCode;
                        }
                    }
                    else
                    {
                        Score[i] = ($"Error: {response.StatusCode} - {response.Content.ReadAsStringAsync().Result}");
                        countrys[i] = ($"Error: {response.StatusCode} - {response.Content.ReadAsStringAsync().Result}");
                    }
                }
                catch (HttpRequestException e)
                {
                    Console.WriteLine($"Error: {e.Message}");
                }

            }
            WriteColumnToCSV(countrys);
            WriteColumnToCSV(Score);
        }
```
Here's how the function works:
   - It first retrieves the IP addresses from the CSV file using `GetColumnAsArry(3)`.
   - For each IP address, it constructs the API URL and sends an HTTP request using `HttpClient`.
   - It sets the necessary headers, including an API key for authentication.
   - It handles the API response and extracts the abuse confidence score and country code from the JSON data.
   - If the abuse confidence score is greater than zero, it stores the score and country code in respective arrays (`Score` and `countrys`).
   - If the API call fails or an error occurs, it stores error messages in the arrays.
   - Finally, it calls `WriteColumnToCSV(countrys)` and `WriteColumnToCSV(Score)` to update the "IP Country" and "AbuseIPDB Score" columns in the CSV file.

<br/>

## VirusTotalIpScanner()`:
This function performs an API call to the VirusTotal service to obtain scan results for the IP addresses present in the CSV file.
```c#
private void VirusTotalIpScanner()
        {
            string[] IPs = GetColumnAsArry(3);
           // string api = myform.vir_api.Text;
            string[] result = new string[IPs.Length];

            for(int i = 0; i < IPs.Length; i++)
            {
                result[i] = VirustotalScaner.GetIpScanResult(IPs[i]);
            }
            
            WriteColumnToCSV (result);
        }
```
Here's how the function works:
   - It first retrieves the IP addresses from the CSV file using `GetColumnAsArry(3)`.
   - For each IP address, it calls an external `VirustotalScaner.GetIpScanResult()` method (not shown here) to obtain the scan result for that IP.
   - The scan results are stored in a string array named `result`.
   - Finally, it calls `WriteColumnToCSV(result)` to update the "VirusTotal" column in the CSV file with the scan results.

<br/>

## LoadCSV
This function orchestrates the entire data processing workflow.
```c#
public DataTable LoadCSV()
        {
            netstat_output();
            GetprocessName();
            GetHostName();
            AbuseIPDBScanAndCountry();
            VirusTotalIpScanner();
            string filePath = "netstat_output.csv";
            DataTable dataTable = new DataTable();

            DataTable dt = new DataTable();
            try
            {
                using (StreamReader sr = new StreamReader(filePath))
                {
                    string line;
                    bool isFirstLine = true;
                    while ((line = sr.ReadLine()) != null)
                    {
                        string[] values = line.Split(',');
                        
                        if (isFirstLine)
                        {
                            dt.Columns.Add("Protcol");
                            dt.Columns.Add("Local Address");
                            dt.Columns.Add("Out port");
                            dt.Columns.Add("Foreign Address");
                            dt.Columns.Add("Connection Port");
                            dt.Columns.Add("State");
                            dt.Columns.Add("PID");
                            dt.Columns.Add("Process Name");
                            dt.Columns.Add("Host Name");
                            dt.Columns.Add("IP Country");
                            dt.Columns.Add("AbuseIPDB Score");
                            dt.Columns.Add("VirusTotal");

                            isFirstLine = false;
                        }
                        DataRow dr = dt.NewRow();
                        dr.ItemArray = values;
                        dt.Rows.Add(dr);
                    }
                }
            }
            catch (Exception ex)
            {
                
            }

            return dt;
        }
```
Here's how the function works:
    - It calls `netstat_output()`, `GetprocessName()`, `GetHostName()`, `AbuseIPDBScanAndCountry()`, and `VirusTotalIpScanner()` methods to process the data and









